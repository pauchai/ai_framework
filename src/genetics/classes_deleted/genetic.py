class Genetic:
    #n
    bot_numbers = 15              # Общее число ботов
    #nsurv
    number_survives = 5           # Количество выживших (столько лучших переходит в новую популяцию)
    #newrand
    new_rand = 5
    #nnew
    nnew = bot_numbers - nsurv - newrand    # Количество новых (столько новых ботов создается)
    #l
    bot_len = 48              # Размер бота
    epohs = 20          # количество эпох поиска
    
    control_std = 0.0003 # выход из поиска если изменение в лучших ниже данного значения

    '''
    Особенности мутации
    '''
    #mut
    mutation_rate = 0.5        # стартовый коэфициент мутаций
    
    eph_change_mut = (2, 4, 6, 8) # эпохи смены коэфициента мутации
    
    new_mut = (0.4, 0.3, 0.2, 0.1) # новый коэфициент мутаци

    '''
    Защищенные гены
    '''
    notchangeidx = (7, 8, 9) # индексы бота защищенные и скрещивания от мутации
    notmutidx = (5, 6) # индексы бота защищенные от мутации
    popul = []         # Массив популяции
    val = []           # Одномерный массив значений этих ботов
   
    def __init__(self):
        pass
 
    def search():
        '''
        Создаём популяцию случайных ботов
        '''
 
        for i in range(self.bot_numbers):
            self.popul.append(create_bot4net())


        '''
        Основной цикл поиска
        '''  
        sval_best = []    # Одномерный массив значений лучших ботов на эпохах
        # Пробегаем по всем эпохам
        for it in range(epohs):                 
            # проверяем текущую эпоху it на принадлежность графику смены мутации
            if it in eph_change_mut:
                idx = eph_change_mut.index(it) # получаем индекс  по эпохе
                mut = new_mut[idx] # проверяем текущую эпохуобновляем мутацию
                print('Смена мутации на', mut)
                print()  

            val = []                              # Обнуляем значения бота
            curr_time = time.time()               # засекаем время

            '''
            Получение оценок ботов
            '''  
            # Пробегаем в цикле по всем ботам 
            for i in range(self.n):                    
                bot = popul[i]                     # Берем очередного бота

                # Вычисляем точность текущего бота
                f = eval_net(bot,           # бот популяции 
                            3,              # к-во эпох проверки 
                            0,              # выводить или нет процесс обучения 
                            train_datagen,  # тренировочные данные
                            val_datagen,    # проверочные данные
                            inputShape[1],  # количество подаваемых шагов в наборе
                            inputShape[2],  # количество каналов данных в наборе
                            outputShape[1], # на сколько предсказываем 
                            x_test,         # тестовая выборка
                            y_test,         # тестовая выборка
                            y_scaler        # скейлер данных
                            ) 
                val.append(f)   # Добавляем полученное значение в список val
            
            '''
            Сортировка оценок ботов и контроль поиса
            ''' 
            sval = sorted(val, reverse=0)         # Сортируем val
            # Выводим 5 лучших ботов
            print(it, time.time() - curr_time, " ", sval[0:5],popul[:5]) 

            sval_best.append(sval[0])             # добавляем значение лучшего бота
            # проверка на продолжение поиска, есть разница или уже нет в точности
            if it > 5:                            # с 6й эпохи 
                sval_best = sorted(sval_best, reverse=0)[:5] # сортируем и берем 5ть лучших 
                if np.std(sval_best) < control_std:          # сверяем значения на отличие 
                    print('Поиск дучших не дает нового, выход')
                    break

            '''
            Сохранение лучших ботов в newpopul
            '''  
            newpopul = [] # Создаем пустой список под новую популяцию
            # Пробегаем по всем выжившим ботам
            for i in range(nsurv):
                # Получаем индекс очередного бота из списка лучших в списке val             
                index = val.index(sval[i])
                # Добавляем в новую популяцию бота из popul с индексом index        
                newpopul.append(popul[index])       
            '''
            Создание новых ботов на основе лучших ботов в newpopul.
            Иногда дополнительно применение мутации и исключения!
            '''
            # Проходимся в цикле nnew-раз 
            for i in range(nnew):
                # случайный выбор родителя в диапазоне от 0 до nsurv - 1              
                indexp1 = random.randint(0,nsurv-1) # Случайный индекс 1го родителя 
                indexp2 = random.randint(0,nsurv-1) # Случайный индекс 1го родителя
                botp1 = newpopul[indexp1]           # бота-родителя 1 по indexp1
                botp2 = newpopul[indexp2]           # бота-родителя  2 по indexp2    
                newbot = []                         # пустой список для нового бота    
                net4Mut = create_bot4net()         # Создаем случайную сеть для мутаций

                # выбираем основного родителя для защищенных генов
                randparent = random.choice((botp1,botp2))

                '''
                Пробегаем по всем генам бота
                '''
                for j in range(l): 
                    # Если ген незащищен от скрещивания 
                    if j not in notchangeidx:                       
                        x = 0      
                        '''
                        Скрещивание
                        '''
                        # Получаем случайное число в диапазоне от 0 до 1
                        pindex = random.random() 
                        # Если pindex меньше 0.5, то берем значения от 1 бота, иначе от 2
                        if pindex < 0.5: x = botp1[j]
                        else: x = botp2[j]
                        
                        '''
                        Мутация
                        '''
                        # Если ген незащищен от мутации
                        if j not in notmutidx:
                            # С вероятностью mut устанавливаем значение бота из net4Mut
                            if (random.random() < mut): x = net4Mut[j]
                            else: pass

                        # Если ген защищен берем от основного         
                        else: x = randparent[j]
                    # Если ген защищен берем от осноаного
                    else: x = randparent[j]
                    newbot.append(x)    # Добавляем очередное значение в нового бота      
                newpopul.append(newbot) # Добавляем бота в новую популяцию      
                '''
                Добавление случайных ботов для разнообразия
                ''' 
                for i in range(newrand):
                    newpopul.append(create_bot4net())
            popul = newpopul   
        